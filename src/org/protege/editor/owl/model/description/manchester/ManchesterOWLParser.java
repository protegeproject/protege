/* Generated By:JavaCC: Do not edit this line. ManchesterOWLParser.java */
package org.protege.editor.owl.model.description.manchester;

import java.io.Reader;
import java.util.Set;
import java.util.HashSet;
import java.util.List;
import java.util.ArrayList;
import java.net.URI;
import org.protege.editor.owl.model.description.*;
import org.semanticweb.owl.vocab.XSDVocabulary;

import org.semanticweb.owl.vocab.OWLRestrictedDataRangeFacetVocabulary;
import static org.semanticweb.owl.vocab.OWLRestrictedDataRangeFacetVocabulary.*;

import org.semanticweb.owl.model.*;

public class ManchesterOWLParser implements ManchesterOWLParserConstants {

    private Set<OWLOntology> ontologies;

    private OWLDataFactory dataFactory;

    private DataTypeMapper dataTypeMapper;

    private EntityMapper entityMapper;

    private boolean create;

    public ManchesterOWLParser(Set<OWLOntology> ontologies, OWLDataFactory dataFactory, EntityMapper entityMapper, DataTypeMapper dataTypeMapper, Reader reader) {
        this(getTokenManager(entityMapper, dataTypeMapper, reader));
        this.entityMapper = entityMapper;
        this.ontologies = ontologies;
        this.dataFactory = dataFactory;
        this.dataTypeMapper = dataTypeMapper;
        if(dataFactory != null) {
            create=true;
        }
    }

    private static ManchesterOWLParserTokenManager getTokenManager(EntityMapper entityMapper, DataTypeMapper dataTypeMapper, Reader reader) {
        ManchesterOWLParserTokenManager tokenManager = new ManchesterOWLParserTokenManager(new SimpleCharStream(reader));
        tokenManager.setEntityMapper(entityMapper);
        tokenManager.setDataTypeMapper(dataTypeMapper);
        return tokenManager;
    }

  final public OWLDescription Parse() throws ParseException {
    OWLDescription desc;
    desc = And();
    jj_consume_token(0);
        {if (true) return desc;}
    throw new Error("Missing return statement in function");
  }

  final public List<OWLObjectPropertyExpression> ParsePropertyChain() throws ParseException {
    List<OWLObjectPropertyExpression> properties = new ArrayList<OWLObjectPropertyExpression>();
    OWLObjectPropertyExpression prop;
    prop = ObjectProperty();
                           properties.add(prop);
    jj_consume_token(COMPOSITION);
    prop = ObjectProperty();
                                                                                       properties.add(prop);
    jj_consume_token(0);
        {if (true) return properties;}
    throw new Error("Missing return statement in function");
  }

  final public OWLClassAxiom ParseClassAxiom() throws ParseException {
    OWLClassAxiom axiom = null;
    OWLDescription clsA = null;
    OWLDescription clsB = null;
    int type = 0;
    clsA = And();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SUBCLASSOF:
      jj_consume_token(SUBCLASSOF);
                                type=0;
      break;
    case EQUIVALENTTO:
      jj_consume_token(EQUIVALENTTO);
                                                          type=1;
      break;
    case DISJPOINTWITH:
      jj_consume_token(DISJPOINTWITH);
                                                                                     type=2;
      break;
    default:
      jj_la1[0] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    clsB = And();
        if(create) {
            if(type == 0) {
                axiom = dataFactory.getOWLSubClassAxiom(clsA, clsB);
            }
            else if(type ==1) {
                Set<OWLDescription> descs = new HashSet<OWLDescription>();
                descs.add(clsA);
                descs.add(clsB);
                axiom = dataFactory.getOWLEquivalentClassesAxiom(descs);
            }
            else {
                Set<OWLDescription> descs = new HashSet<OWLDescription>();
                descs.add(clsA);
                descs.add(clsB);
                axiom = dataFactory.getOWLDisjointClassesAxiom(descs);
            }
        }
        {if (true) return axiom;}
    throw new Error("Missing return statement in function");
  }

  final public SWRLRule ParseRule() throws ParseException {
    List<SWRLAtom> body;
    List<SWRLAtom> head;
    body = RuleAtomList();
    jj_consume_token(RULE_IMP);
    head = RuleAtomList();
    jj_consume_token(0);
        {if (true) return dataFactory.getSWRLRule(new HashSet<SWRLAtom>(body), new HashSet<SWRLAtom>(head));}
    throw new Error("Missing return statement in function");
  }

  final public List<SWRLAtom> RuleAtomList() throws ParseException {
    SWRLAtom atom;
    List<SWRLAtom> list = new ArrayList<SWRLAtom>();
    atom = RuleAtom();
                       list.add(atom);
    label_1:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[1] = jj_gen;
        break label_1;
      }
      jj_consume_token(COMMA);
      atom = RuleAtom();
                                                                    list.add(atom);
    }
        {if (true) return list;}
    throw new Error("Missing return statement in function");
  }

  final public SWRLAtom RuleAtom() throws ParseException {
    SWRLAtom atom;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPENPAR:
    case OPENBRACE:
    case CLASSID:
      atom = ClassAtom();
      break;
    case INV:
    case OBJECTPROPID:
      atom = ObjectPropertyAtom();
      break;
    case DATATYPEID:
      atom = DataRangeAtom();
      break;
    default:
      jj_la1[2] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        {if (true) return atom;}
    throw new Error("Missing return statement in function");
  }

  final public SWRLAtom ClassAtom() throws ParseException {
    OWLDescription desc;
    SWRLAtomIObject iobject;
    desc = NamedClassOrNestedDescription();
    jj_consume_token(OPENPAR);
    iobject = IObject();
    jj_consume_token(CLOSEPAR);
        {if (true) return dataFactory.getSWRLClassAtom(desc, iobject);}
    throw new Error("Missing return statement in function");
  }

  final public SWRLAtomIObject IObject() throws ParseException {
    SWRLAtomIObject iobject;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INDIVIDUALID:
      iobject = IndividualObject();
      break;
    case QUESTION_MARK:
      iobject = IVariable();
      break;
    default:
      jj_la1[3] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        {if (true) return iobject;}
    throw new Error("Missing return statement in function");
  }

  final public SWRLAtomIVariable IVariable() throws ParseException {
    Token t;
    SWRLAtomIVariable ivariable;
    jj_consume_token(QUESTION_MARK);
    t = jj_consume_token(IDENTIFIER);
        String shortName = t.image.trim();
        URI uri = URI.create("http://www.semanticweb.org/ontologies#" +  t.image);
        {if (true) return dataFactory.getSWRLAtomIVariable(uri);}
    throw new Error("Missing return statement in function");
  }

  final public SWRLAtomIndividualObject IndividualObject() throws ParseException {
    OWLIndividual ind;
    ind = Individual();
        if(create) {
            {if (true) return dataFactory.getSWRLAtomIndividualObject(ind);}
        }
        else {
            {if (true) return null;}
        }
    throw new Error("Missing return statement in function");
  }

  final public SWRLAtom DataRangeAtom() throws ParseException {
    OWLDataRange dr;
    SWRLAtomDObject dobject;
    dr = DataRange();
    jj_consume_token(OPENPAR);
    dobject = DObject();
    jj_consume_token(CLOSEPAR);
        {if (true) return dataFactory.getSWRLDataRangeAtom(dr, dobject);}
    throw new Error("Missing return statement in function");
  }

  final public SWRLAtomDObject DObject() throws ParseException {
    SWRLAtomDObject dobject;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INT:
    case FLOAT:
    case BOOLEAN:
    case STRING:
      dobject = ConstantObject();
      break;
    case QUESTION_MARK:
      dobject = DVariable();
      break;
    default:
      jj_la1[4] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        {if (true) return dobject;}
    throw new Error("Missing return statement in function");
  }

  final public SWRLAtomDVariable DVariable() throws ParseException {
    Token t;
    SWRLAtomDVariable dvariable;
    jj_consume_token(QUESTION_MARK);
    t = jj_consume_token(IDENTIFIER);
        String shortName = t.image.trim();
        URI uri = URI.create("http://www.semanticweb.org/ontologies#" +  t.image);
        {if (true) return dataFactory.getSWRLAtomDVariable(uri);}
    throw new Error("Missing return statement in function");
  }

  final public SWRLAtomDObject ConstantObject() throws ParseException {
    OWLConstant con;
    con = DataValue();
        {if (true) return dataFactory.getSWRLAtomConstantObject(con);}
    throw new Error("Missing return statement in function");
  }

  final public SWRLAtom ObjectPropertyAtom() throws ParseException {
    SWRLAtomIObject obj0;
    SWRLAtomIObject obj1;
    OWLObjectPropertyExpression prop;
    prop = ObjectProperty();
    jj_consume_token(OPENPAR);
    obj0 = IObject();
    jj_consume_token(COMMA);
    obj1 = IObject();
    jj_consume_token(CLOSEPAR);
        {if (true) return dataFactory.getSWRLObjectPropertyAtom(prop, obj0, obj1);}
    throw new Error("Missing return statement in function");
  }

/*
OWLDescriptionNode ParseQuery() :
{
    OWLDescriptionNode node;
}
{
    node = ParseNodeUnion() <EOF> {
        return node;
    }
}

OWLDescriptionNode ParseNodeUnion() :
{
    OWLDescriptionNode leftNode = null, rightNode = null;
}
{
    (leftNode = ParseNodeDifference()

    (<PLUS>

    rightNode = ParseNodeDifference())*) {
        if(create) {
            if(rightNode != null) {
                return new OWLDescriptionNodeUnion(leftNode, rightNode);
            }
            else {
                return leftNode;
            }
        }
        return null;
    }
}


OWLDescriptionNode ParseNodeDifference() :
{
    OWLDescriptionNode leftNode = null, rightNode = null;
}
{
    (leftNode = ParseNodePossibly()

    (<MINUS>

    rightNode = ParseNodePossibly())*) {
        if(create) {
            if(rightNode != null) {
                return new OWLDescriptionNodeDifference(leftNode, rightNode);
            }
            else {
                return leftNode;
            }
        }
        return null;
    }
}

OWLDescriptionNode ParseNodePossibly() :
{
    OWLDescriptionNode leftNode = null, rightNode = null;
}
{
    (leftNode = ParseNode()

    (<POSSIBLY>

    rightNode = ParseNode())*) {
        if(create) {
            if(rightNode != null) {
                return new OWLDescriptionNodePossibly(leftNode, rightNode);
            }
            else {
                return leftNode;
            }
        }
        return null;
    }
}


OWLDescriptionNode ParseNode() :
{
    OWLDescriptionNode node;
    OWLDescription desc;
}
{
    (desc = And() {
        if(create) {
            return new OWLDescriptionLeafNode(desc);
        }
        return null;
    })
    |
    ((
    <OPENSQPAR>
    node = ParseNodeUnion()
    <CLOSESQPAR>
    ) {return node;})
}

*/
  final public OWLDescription And() throws ParseException {
    Set<OWLDescription> descriptions = new HashSet();
    OWLDescription desc0;
    OWLDescription descN;
    desc0 = Or();
        descriptions.add(desc0);
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AND:
        ;
        break;
      default:
        jj_la1[5] = jj_gen;
        break label_2;
      }
      jj_consume_token(AND);
      descN = Or();
                           descriptions.add(descN);
    }
        if(create) {
            if(descriptions.size() == 1) {
                {if (true) return desc0;}
            }
            else {
                {if (true) return dataFactory.getOWLObjectIntersectionOf(descriptions);}
            }
        }
        {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

  final public OWLDescription Or() throws ParseException {
    Set<OWLDescription> descriptions;
    descriptions = new HashSet<OWLDescription>();
    OWLDescription desc0;
    OWLDescription descN;
    desc0 = ClassDescription();
        if(create) {
            descriptions.add(desc0);
        }
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OR:
        ;
        break;
      default:
        jj_la1[6] = jj_gen;
        break label_3;
      }
      jj_consume_token(OR);
      descN = ClassDescription();
        if(create) {
            descriptions.add(descN);
        }
    }
        if(create) {
            if(descriptions.size() > 1) {
                {if (true) return dataFactory.getOWLObjectUnionOf(descriptions);}
            }
            else {
                {if (true) return desc0;}
            }
        }
        {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

  final public OWLDescription Not() throws ParseException {
    OWLDescription desc;
    jj_consume_token(NOT);
    desc = NamedClassOrNestedDescription();
        if(create) {
            {if (true) return dataFactory.getOWLObjectComplementOf(desc);}
        }
        {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

  final public OWLDescription ClassDescription() throws ParseException {
    OWLDescription desc = null;
    OWLDescription thatDesc = null;
    Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case CLASSID:
      desc = NamedClass();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case THAT:
        desc = ThatRestriction(desc);
        break;
      default:
        jj_la1[7] = jj_gen;
        ;
      }
      break;
    case INV:
    case OBJECTPROPID:
    case DATAPROPID:
      desc = Restriction();
      break;
    case OPENBRACE:
      desc = ObjectEnumeration();
      break;
    case NOT:
      desc = Not();
      break;
    case OPENPAR:
      jj_consume_token(OPENPAR);
      desc = And();
      jj_consume_token(CLOSEPAR);
      break;
    default:
      jj_la1[8] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        {if (true) return desc;}
    throw new Error("Missing return statement in function");
  }

  final public OWLDescription ThatRestriction(OWLDescription namedClass) throws ParseException {
    OWLDescription desc = null;
    jj_consume_token(THAT);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INV:
    case OBJECTPROPID:
    case DATAPROPID:
      desc = Restriction();
      break;
    case OPENPAR:
      jj_consume_token(OPENPAR);
      desc = Restriction();
      jj_consume_token(CLOSEPAR);
      break;
    default:
      jj_la1[9] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        if(create) {
            Set<OWLDescription> ops = new HashSet<OWLDescription>();
            ops.add(namedClass);
            ops.add(desc);
            {if (true) return dataFactory.getOWLObjectIntersectionOf(ops);}
        }
        {if (true) return desc;}
    throw new Error("Missing return statement in function");
  }

  final public OWLDescription Restriction() throws ParseException {
    OWLDescription desc;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INV:
    case OBJECTPROPID:
      desc = ObjectRestriction();
      break;
    case DATAPROPID:
      desc = DataRestriction();
      break;
    default:
      jj_la1[10] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        {if (true) return desc;}
    throw new Error("Missing return statement in function");
  }

  final public OWLDataProperty DataProperty() throws ParseException {
    Token t;
    OWLDataProperty prop;
    t = jj_consume_token(DATAPROPID);
        if(create) {
            {if (true) return (OWLDataProperty) entityMapper.getOWLEntity(t.image);}
        }
        {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

  final public OWLDescription DataRestriction() throws ParseException {
    OWLDataProperty prop;
    OWLDataRange dataRangeFiller;
    OWLConstant valueFiller;
    prop = DataProperty();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SOME:
      dataRangeFiller = DataSomeRestriction();
            if(create) {
                {if (true) return dataFactory.getOWLDataSomeRestriction(prop, dataRangeFiller);}
            }
            {if (true) return null;}
      break;
    case ALL:
      dataRangeFiller = DataAllRestriction();
            if(create) {
                {if (true) return dataFactory.getOWLDataAllRestriction(prop, dataRangeFiller);}
            }
            {if (true) return null;}
      break;
    case HAS:
      valueFiller = DataValueRestriction();
            if(create) {
                {if (true) return dataFactory.getOWLDataValueRestriction(prop, valueFiller);}
            }
            {if (true) return null;}
      break;
    default:
      jj_la1[11] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public OWLObjectPropertyExpression ObjectProperty() throws ParseException {
    Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OBJECTPROPID:
      t = jj_consume_token(OBJECTPROPID);
        if(create) {
            {if (true) return (OWLObjectProperty) entityMapper.getOWLEntity(t.image);}
        }
        {if (true) return null;}
      break;
    case INV:
      jj_consume_token(INV);
      jj_consume_token(OPENPAR);
      t = jj_consume_token(OBJECTPROPID);
      jj_consume_token(CLOSEPAR);
            if(create) {
                OWLObjectProperty prop = (OWLObjectProperty) entityMapper.getOWLEntity(t.image);
                {if (true) return dataFactory.getOWLObjectPropertyInverse(prop);}
            }
            {if (true) return null;}
      break;
    default:
      jj_la1[12] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public OWLDescription ObjectRestriction() throws ParseException {
    OWLObjectPropertyExpression prop;
    OWLDescription descFiller;
    OWLIndividual valueFiller;
    prop = ObjectProperty();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case SOME:
      descFiller = ObjectSomeRestriction();
        if(create) {
            {if (true) return dataFactory.getOWLObjectSomeRestriction(prop, descFiller);}
        }
        {if (true) return null;}
      break;
    case ALL:
      descFiller = ObjectAllRestriction();
        if(create) {
            {if (true) return dataFactory.getOWLObjectAllRestriction(prop, descFiller);}
        }
        {if (true) return null;}
      break;
    case HAS:
      valueFiller = ObjectValueRestriction();
        if(create) {
            {if (true) return dataFactory.getOWLObjectValueRestriction(prop, valueFiller);}
        }
        {if (true) return null;}
      break;
    case MIN:
    case MAX:
    case EXACT:
      descFiller = ObjectCardinality(prop);
        {if (true) return descFiller;}
      break;
    default:
      jj_la1[13] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public OWLIndividual Individual() throws ParseException {
    Token t;
    t = jj_consume_token(INDIVIDUALID);
        if(create) {
            {if (true) return (OWLIndividual) entityMapper.getOWLEntity(t.image);}
        }
        {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

  final public OWLDescription ObjectEnumeration() throws ParseException {
    Set<OWLIndividual> individuals = new HashSet();
    OWLIndividual ind;
    jj_consume_token(OPENBRACE);
    label_4:
    while (true) {
      ind = Individual();
                                      individuals.add(ind);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case INDIVIDUALID:
        ;
        break;
      default:
        jj_la1[14] = jj_gen;
        break label_4;
      }
    }
    jj_consume_token(CLOSEBRACE);
        if(create) {
            {if (true) return dataFactory.getOWLObjectOneOf(individuals);}
        }
        {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

  final public OWLDataRange DataRange() throws ParseException {
    Token t;
    List<OWLDataRangeFacetRestriction> restrictions = new ArrayList<OWLDataRangeFacetRestriction>();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case DATATYPEID:
      t = jj_consume_token(DATATYPEID);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPENSQPAR:
        jj_consume_token(OPENSQPAR);
        restrictions = DataRestrictionFacetList();
        jj_consume_token(CLOSESQPAR);
        break;
      default:
        jj_la1[15] = jj_gen;
        ;
      }
        if(create) {
            URI uri = dataTypeMapper.getOWLDataTypeURI(t.image);
            OWLDataRange dt = dataFactory.getOWLDataType(uri);
            if(!restrictions.isEmpty()) {
                dt = dataFactory.getOWLDataRangeRestriction(dt, new HashSet<OWLDataRangeFacetRestriction>(restrictions));
            }
            {if (true) return dt;}
        }
        {if (true) return null;}
      break;
    case OPENBRACE:
      jj_consume_token(OPENBRACE);
      label_5:
      while (true) {
        DataValue();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case INT:
        case FLOAT:
        case BOOLEAN:
        case STRING:
          ;
          break;
        default:
          jj_la1[16] = jj_gen;
          break label_5;
        }
      }
      jj_consume_token(CLOSEBRACE);
      break;
    default:
      jj_la1[17] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
        {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

  final public List<OWLDataRangeFacetRestriction> DataRestrictionFacetList() throws ParseException {
    OWLDataRangeFacetRestriction restriction;
    List<OWLDataRangeFacetRestriction> restrictions = new ArrayList<OWLDataRangeFacetRestriction>();
    restriction = DataRestrictionFacetRestriction();
     restrictions.add(restriction);
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case COMMA:
        ;
        break;
      default:
        jj_la1[18] = jj_gen;
        break label_6;
      }
      jj_consume_token(COMMA);
      restriction = DataRestrictionFacetRestriction();
                                                           restrictions.add(restriction);
    }
        {if (true) return restrictions;}
    throw new Error("Missing return statement in function");
  }

  final public OWLDataRangeFacetRestriction DataRestrictionFacetRestriction() throws ParseException {
    OWLRestrictedDataRangeFacetVocabulary v;
    OWLTypedConstant con;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case MIN_EXC:
      jj_consume_token(MIN_EXC);
                v = MIN_EXCLUSIVE;
      break;
    case MIN_INC:
      jj_consume_token(MIN_INC);
                v = MIN_INCLUSIVE;
      break;
    case MAX_EXC:
      jj_consume_token(MAX_EXC);
                v = MAX_EXCLUSIVE;
      break;
    case MAX_INC:
      jj_consume_token(MAX_INC);
                v = MAX_INCLUSIVE;
      break;
    case LEN:
      jj_consume_token(LEN);
            v = LENGTH;
      break;
    case PAT:
      jj_consume_token(PAT);
            v = PATTERN;
      break;
    default:
      jj_la1[19] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    con = DataValue();
        if(create) {
            {if (true) return dataFactory.getOWLDataRangeFacetRestriction(v, con);}
        }
        {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

  final public OWLTypedConstant DataValue() throws ParseException {
    int ival;
    float fval;
    String sval;
    String lit;
    boolean bval;
    Token t;
    URI dtURI = XSDVocabulary.STRING.getURI();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case INT:
      ival = Integer();
        if(create) {
            {if (true) return dataFactory.getOWLTypedConstant(
                    Integer.toString(ival),
                    dataFactory.getOWLDataType(XSDVocabulary.INT.getURI())
            );}
        }
        {if (true) return null;}
      break;
    case FLOAT:
      fval = Float();
            if(create) {
                {if (true) return dataFactory.getOWLTypedConstant(
                    Float.toString(fval),
                    dataFactory.getOWLDataType(XSDVocabulary.FLOAT.getURI())
                );}
            }
            {if (true) return null;}
      break;
    case BOOLEAN:
      bval = Boolean();
            if(create) {
                {if (true) return dataFactory.getOWLTypedConstant(
                    Boolean.toString(bval),
                    dataFactory.getOWLDataType(XSDVocabulary.BOOLEAN.getURI())
                );}
            }
            {if (true) return null;}
      break;
    case STRING:
      sval = String();
      jj_consume_token(DOUBLE_CARET);
      t = jj_consume_token(DATATYPEID);
                                                       dtURI=dataTypeMapper.getOWLDataTypeURI(t.image);
            if(create) {
                    {if (true) return dataFactory.getOWLTypedConstant(
                    sval,
                    dataFactory.getOWLDataType(dtURI));}

            }
            {if (true) return null;}
      break;
    default:
      jj_la1[20] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

///////////////////////////////////////////////////////////////////////////////////////////////
//
// Existential restrictions
//
///////////////////////////////////////////////////////////////////////////////////////////////
  final public OWLDataRange DataSomeRestriction() throws ParseException {
    OWLDataRange rng;
    jj_consume_token(SOME);
    rng = DataRange();
        {if (true) return rng;}
    throw new Error("Missing return statement in function");
  }

  final public OWLDescription ObjectSomeRestriction() throws ParseException {
    OWLDescription desc;
    jj_consume_token(SOME);
    desc = NamedClassOrNestedDescription();
        {if (true) return desc;}
    throw new Error("Missing return statement in function");
  }

///////////////////////////////////////////////////////////////////////////////////////////////
//
// Universal restrictions
//
///////////////////////////////////////////////////////////////////////////////////////////////
  final public OWLDataRange DataAllRestriction() throws ParseException {
    OWLDataRange rng;
    jj_consume_token(ALL);
    rng = DataRange();
        {if (true) return rng;}
    throw new Error("Missing return statement in function");
  }

  final public OWLDescription ObjectAllRestriction() throws ParseException {
    OWLDescription desc;
    jj_consume_token(ALL);
    desc = NamedClassOrNestedDescription();
        {if (true) return desc;}
    throw new Error("Missing return statement in function");
  }

/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Value restrictions
//
/////////////////////////////////////////////////////////////////////////////////////////////////
  final public OWLIndividual ObjectValueRestriction() throws ParseException {
    OWLIndividual ind;
    jj_consume_token(HAS);
    ind = Individual();
        {if (true) return ind;}
    throw new Error("Missing return statement in function");
  }

  final public OWLConstant DataValueRestriction() throws ParseException {
    OWLConstant value;
    jj_consume_token(HAS);
    value = DataValue();
        {if (true) return value;}
    throw new Error("Missing return statement in function");
  }

/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Object Cardinality
//
/////////////////////////////////////////////////////////////////////////////////////////////////
  final public OWLDescription ObjectCardinality(OWLObjectPropertyExpression prop) throws ParseException {
    int i;
    OWLDescription desc = null;
    boolean min = false;
    boolean exact = false;
    boolean max = false;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case MIN:
      jj_consume_token(MIN);
             min=true;
      break;
    case EXACT:
      jj_consume_token(EXACT);
                                  exact=true;
      break;
    case MAX:
      jj_consume_token(MAX);
                                                       max=true;
      break;
    default:
      jj_la1[21] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    i = Integer();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPENPAR:
    case OPENBRACE:
    case CLASSID:
      desc = NamedClassOrNestedDescription();
      break;
    default:
      jj_la1[22] = jj_gen;
      ;
    }
        if(create) {
            if(desc == null) {
                desc = dataFactory.getOWLThing();
            }
            if(min) {
                {if (true) return dataFactory.getOWLObjectMinCardinalityRestriction(prop, i, desc);}
            }
            else if(exact) {
                {if (true) return dataFactory.getOWLObjectExactCardinalityRestriction(prop, i, desc);}
            }
            else {
                {if (true) return dataFactory.getOWLObjectMaxCardinalityRestriction(prop, i, desc);}
            }
        }
        {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

  final public int Integer() throws ParseException {
    Token t;
    int i = -1;
    t = jj_consume_token(INT);
        if(create) {
            i = Integer.parseInt(t.image);
        }
        {if (true) return i;}
    throw new Error("Missing return statement in function");
  }

  final public float Float() throws ParseException {
    Token t;
    float f = 1.0f;
    t = jj_consume_token(FLOAT);
        if(create) {
            f = Float.parseFloat(t.image);
        }
        {if (true) return f;}
    throw new Error("Missing return statement in function");
  }

  final public boolean Boolean() throws ParseException {
    Token t;
    boolean b = false;
    t = jj_consume_token(BOOLEAN);
        if(create) {
            b = Boolean.parseBoolean(t.image);
        }
        {if (true) return b;}
    throw new Error("Missing return statement in function");
  }

  final public String String() throws ParseException {
    Token t;
    t = jj_consume_token(STRING);
        if(create) {
            {if (true) return t.image.substring(1, t.image.length() -1);}
        }
        {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

/////////////////////////////////////////////////////////////////////////////////////////////////
//
// Data Cardinality
//
/////////////////////////////////////////////////////////////////////////////////////////////////
  final public OWLDescription DataCardinality(OWLDataProperty prop) throws ParseException {
    int i;
    boolean min = false;
    boolean exact = false;
    boolean max = false;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case MIN:
      jj_consume_token(MIN);
            min=true;
      break;
    case EXACT:
      jj_consume_token(EXACT);
                                 exact=true;
      break;
    case MAX:
      jj_consume_token(MAX);
                                                      max=true;
      break;
    default:
      jj_la1[23] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    i = Integer();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPENBRACE:
    case DATATYPEID:
      DataRange();
      break;
    default:
      jj_la1[24] = jj_gen;
      ;
    }
        if(create) {
            if(min) {
                {if (true) return dataFactory.getOWLDataMinCardinalityRestriction(prop, i);}
            }
            if(exact) {
                {if (true) return dataFactory.getOWLDataExactCardinalityRestriction(prop, i);}
            }
            if(max) {
                {if (true) return dataFactory.getOWLDataMaxCardinalityRestriction(prop, i);}
            }
        }
        {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

  final public OWLDescription NamedClassOrNestedDescription() throws ParseException {
    OWLDescription desc;
    Token t;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case OPENPAR:
    case CLASSID:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case OPENPAR:
        jj_consume_token(OPENPAR);
        desc = And();
        jj_consume_token(CLOSEPAR);
        break;
      case CLASSID:
        desc = NamedClass();
        break;
      default:
        jj_la1[25] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
        if(create) {
            {if (true) return desc;}
        }
        {if (true) return null;}
      break;
    case OPENBRACE:
      desc = ObjectEnumeration();
        if(create) {
            {if (true) return desc;}
        }
        {if (true) return null;}
      break;
    default:
      jj_la1[26] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  final public OWLDescription NamedClass() throws ParseException {
    Token t;
    OWLDescription desc;
    t = jj_consume_token(CLASSID);
        desc = (OWLClass) entityMapper.getOWLEntity(t.image);
        if(create) {
            {if (true) return desc;}
        }
        {if (true) return null;}
    throw new Error("Missing return statement in function");
  }

  public ManchesterOWLParserTokenManager token_source;
  SimpleCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[27];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_0();
      jj_la1_1();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0x1c000000,0x1000000,0x820,0x200,0x200,0x4000,0x8000,0x800000,0x10820,0x20,0x0,0xe0000,0x0,0x7e0000,0x0,0x80,0x0,0x800,0x1000000,0x0,0x0,0x700000,0x820,0x700000,0x800,0x20,0x820,};
   }
   private static void jj_la1_1() {
      jj_la1_1 = new int[] {0x0,0x0,0x4c002,0x20000,0x1b00,0x0,0x0,0x0,0x1c002,0x18002,0x18002,0x0,0x8002,0x0,0x20000,0x0,0x1b00,0x40000,0x0,0xfc,0x1b00,0x0,0x4000,0x0,0x40000,0x4000,0x4000,};
   }

  public ManchesterOWLParser(java.io.InputStream stream) {
     this(stream, null);
  }
  public ManchesterOWLParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new ManchesterOWLParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 27; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 27; i++) jj_la1[i] = -1;
  }

  public ManchesterOWLParser(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new ManchesterOWLParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 27; i++) jj_la1[i] = -1;
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 27; i++) jj_la1[i] = -1;
  }

  public ManchesterOWLParser(ManchesterOWLParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 27; i++) jj_la1[i] = -1;
  }

  public void ReInit(ManchesterOWLParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 27; i++) jj_la1[i] = -1;
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector jj_expentries = new java.util.Vector();
  private int[] jj_expentry;
  private int jj_kind = -1;

  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[53];
    for (int i = 0; i < 53; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 27; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 53; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

}
